# NOTE These are basically just stolen from YCM's default cpp completions. I've just made a bunch
# of style changes and a few changes of substance.
import os

# These are the compilation flags that will be used in case there's no compilation database set (by
# default, one is not set).
# CHANGE THIS LIST OF FLAGS. YES, THIS IS THE DROID YOU HAVE BEEN LOOKING FOR.
COMMON_FLAGS = ['-Wall', '-Wextra', '-Werror', '-Wpedantic', '-Weverything']

C_STD = "-std=c99"
CPP_STD = "-std=c++14"

DATABASE = None

HERE = os.path.dirname(os.path.__abspath(__file__))

# Some of these will only work on OS X, but extra paths that don't exist are not harmful.
PATHS = ['/System/Library/Frameworks/Python.framework/Headers',
         '-isystem',
         '../llvm/include',
         '-isystem',
         '../llvm/tools/clang/include',
         '-I',
         '.',
         '-I',
         './ClangCompleter',
         '-isystem',
         '/usr/include',
         '-isystem',
         '/usr/local/include',
         '-isystem',
         '/Applications/Xcode.app/Contents/Developer/Toolchains/' +
         'XcodeDefault.xctoolchain/usr/bin/../include/c++/v1',
         '-isystem',
         '/Applications/Xcode.app/Contents/Developer/Toolchains/' +
         'XcodeDefault.xctoolchain/usr/include']

SOURCE_EXTENSIONS = ['.cpp', '.cxx', '.cc', '.c', '.m', '.mm']


def is_header_file(filename):
    extension = os.path.splitext(filename)[1]
    return extension in ['.h', '.hxx', '.hpp', '.hh']


def MakeRelativePathsInFlagsAbsolute(flags, working_directory):
    if not working_directory:
        return list(flags)

    new_flags = []
    make_next_absolute = False
    path_flags = ['-isystem', '-I', '-iquote', '--sysroot=']
    for flag in flags:
        new_flag = flag

        if make_next_absolute:
            make_next_absolute = False
            if not flag.startswith('/'):
                new_flag = os.path.join(working_directory, flag)

        for path_flag in path_flags:
            if flag == path_flag:
                make_next_absolute = True
                break

            if flag.startswith(path_flag):
                path = flag[len(path_flag):]
                new_flag = path_flag + os.path.join(working_directory, path)
                break

        if new_flag:
            new_flags.append(new_flag)
    return new_flags


def GetCompilationInfoForFile(filename):
    # The compilation_commands.json file generated by CMake does not have entries for header files.
    # So we do our best by asking the db for flags for a corresponding source file, if any. If one
    # exists, the flags for that file should be good enough.
    if is_header_file(filename):
        basename = os.path.splitext(filename)[0]
        for extension in SOURCE_EXTENSIONS:
            replacement_file = basename + extension
            if os.path.exists(replacement_file):
                compilation_info = DATABASE.GetCompilationInfoForFile(replacement_file)
                if compilation_info.compiler_flags_:
                    return compilation_info

        return None

    return DATABASE.GetCompilationInfoForFile(filename)


def FlagsForFile(filename, **kwargs):
    if DATABASE:
        # Bear in mind that compilation_info.compiler_flags_ does NOT return a python list, but a
        # "list-like" StringVec object
        compilation_info = GetCompilationInfoForFile(filename)
        if not compilation_info:
            return None

        final_flags = MakeRelativePathsInFlagsAbsolute(compilation_info.compiler_flags_,
                                                       compilation_info.compiler_working_dir_)

    else:
        relative_to = HERE
        final_flags = MakeRelativePathsInFlagsAbsolute(C_FLAGS, relative_to)

    return {'flags': final_flags, 'do_cache': True}
